var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This file was auto-generated by `client-gen`.
 * Do not make direct changes to the file.
 */
import { GraphQLClient } from "graphql-request";
import { computeQuery } from "./utils.js";
class BaseClient {
    /**
     * @hidden
     */
    constructor({ queryTree, host, sessionToken } = {}) {
        this._queryTree = queryTree || [];
        this.clientHost = host || "127.0.0.1:8080";
        this.sessionToken = sessionToken || "";
        this.client = new GraphQLClient(`http://${host}/query`, {
            headers: {
                Authorization: "Basic " + Buffer.from(sessionToken + ":").toString("base64"),
            },
        });
    }
    /**
     * @hidden
     */
    get queryTree() {
        return this._queryTree;
    }
}
/**
 * Sharing mode of the cache volume.
 */
export var CacheSharingMode;
(function (CacheSharingMode) {
    /**
     * Shares the cache volume amongst many build pipelines,
     * but will serialize the writes
     */
    CacheSharingMode[CacheSharingMode["Locked"] = 0] = "Locked";
    /**
     * Keeps a cache volume for a single build pipeline
     */
    CacheSharingMode[CacheSharingMode["Private"] = 1] = "Private";
    /**
     * Shares the cache volume amongst many build pipelines
     */
    CacheSharingMode[CacheSharingMode["Shared"] = 2] = "Shared";
})(CacheSharingMode || (CacheSharingMode = {}));
/**
 * Compression algorithm to use for image layers.
 */
export var ImageLayerCompression;
(function (ImageLayerCompression) {
    ImageLayerCompression[ImageLayerCompression["Estargz"] = 0] = "Estargz";
    ImageLayerCompression[ImageLayerCompression["Gzip"] = 1] = "Gzip";
    ImageLayerCompression[ImageLayerCompression["Uncompressed"] = 2] = "Uncompressed";
    ImageLayerCompression[ImageLayerCompression["Zstd"] = 3] = "Zstd";
})(ImageLayerCompression || (ImageLayerCompression = {}));
/**
 * Mediatypes to use in published or exported image metadata.
 */
export var ImageMediaTypes;
(function (ImageMediaTypes) {
    ImageMediaTypes[ImageMediaTypes["Dockermediatypes"] = 0] = "Dockermediatypes";
    ImageMediaTypes[ImageMediaTypes["Ocimediatypes"] = 1] = "Ocimediatypes";
})(ImageMediaTypes || (ImageMediaTypes = {}));
/**
 * Transport layer network protocol associated to a port.
 */
export var NetworkProtocol;
(function (NetworkProtocol) {
    /**
     * TCP (Transmission Control Protocol)
     */
    NetworkProtocol[NetworkProtocol["Tcp"] = 0] = "Tcp";
    /**
     * UDP (User Datagram Protocol)
     */
    NetworkProtocol[NetworkProtocol["Udp"] = 1] = "Udp";
})(NetworkProtocol || (NetworkProtocol = {}));
/**
 * A directory whose contents persist across runs.
 */
export class CacheVolume extends BaseClient {
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * An OCI-compatible container, also known as a docker container.
 */
export class Container extends BaseClient {
    /**
     * Initializes this container from a Dockerfile build.
     * @param context Directory context used by the Dockerfile.
     * @param opts.dockerfile Path to the Dockerfile to use.
     *
     * Default: './Dockerfile'.
     * @param opts.buildArgs Additional build arguments.
     * @param opts.target Target build stage to build.
     * @param opts.secrets Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name].
     */
    build(context, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "build",
                    args: Object.assign({ context }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves default arguments for future commands.
     */
    defaultArgs() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "defaultArgs",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves a directory at the given path.
     *
     * Mounts are included.
     * @param path The path of the directory to retrieve (e.g., "./src").
     */
    directory(path) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "directory",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves an endpoint that clients can use to reach this container.
     *
     * If no port is specified, the first exposed port is used. If none exist an error is returned.
     *
     * If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     * @param opts.port The exposed port number for the endpoint
     * @param opts.scheme Return a URL with the given scheme, eg. http for http://
     */
    endpoint(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "endpoint",
                    args: Object.assign({}, opts),
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves entrypoint to be prepended to the arguments of all commands.
     */
    entrypoint() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "entrypoint",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the value of the specified environment variable.
     * @param name The name of the environment variable to retrieve (e.g., "PATH").
     */
    envVariable(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "envVariable",
                    args: { name },
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the list of environment variables passed to commands.
     */
    envVariables() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "envVariables",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves this container after executing the specified command inside it.
     * @param opts.args Command to run instead of the container's default command (e.g., ["run", "main.go"]).
     * @param opts.stdin Content to write to the command's standard input before closing (e.g., "Hello world").
     * @param opts.redirectStdout Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
     * @param opts.redirectStderr Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
     * @param opts.experimentalPrivilegedNesting Provide dagger access to the executed command.
     * Do not use this option unless you trust the command being executed.
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
     * @deprecated Replaced by withExec.
     */
    exec(opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "exec",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Exit code of the last executed command. Zero means success.
     *
     * Will execute default command if none is set, or error if there's no default.
     * @deprecated Use sync instead.
     */
    exitCode() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "exitCode",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.
     *
     * Return true on success.
     * It can also publishes platform variants.
     * @param path Host's destination path (e.g., "./tarball").
     * Path can be relative to the engine's workdir or absolute.
     * @param opts.platformVariants Identifiers for other platform specific containers.
     * Used for multi-platform image.
     * @param opts.forcedCompression Force each layer of the exported image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     * @param opts.mediaTypes Use the specified media types for the exported image's layers. Defaults to OCI, which
     * is largely compatible with most recent container runtimes, but Docker may be needed
     * for older runtimes without OCI support.
     */
    export(path, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "export",
                    args: Object.assign({ path }, opts),
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the list of exposed ports.
     *
     * This includes ports already exposed by the image, even if not
     * explicitly added with dagger.
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     */
    exposedPorts() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "exposedPorts",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves a file at the given path.
     *
     * Mounts are included.
     * @param path The path of the file to retrieve (e.g., "./README.md").
     */
    file(path) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "file",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Initializes this container from a pulled base image.
     * @param address Image's address from its registry.
     *
     * Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
     */
    from(address) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "from",
                    args: { address },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container's root filesystem. Mounts are not included.
     * @deprecated Replaced by rootfs.
     */
    fs() {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "fs",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves a hostname which can be used by clients to reach this container.
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     */
    hostname() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "hostname",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * A unique identifier for this container.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The unique image reference which can only be retrieved immediately after the 'Container.From' call.
     */
    imageRef() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "imageRef",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Reads the container from an OCI tarball.
     *
     * NOTE: this involves unpacking the tarball to an OCI store on the host at
     * $XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.
     * @param source File to read the container from.
     * @param opts.tag Identifies the tag to import from the archive, if the archive bundles
     * multiple tags.
     */
    import(source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "import",
                    args: Object.assign({ source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves the value of the specified label.
     */
    label(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "label",
                    args: { name },
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the list of labels passed to container.
     */
    labels() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "labels",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the list of paths where a directory is mounted.
     */
    mounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "mounts",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Creates a named sub-pipeline
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "pipeline",
                    args: Object.assign({ name }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * The platform this container executes and publishes as.
     */
    platform() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "platform",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Publishes this container as a new image to the specified address.
     *
     * Publish returns a fully qualified ref.
     * It can also publish platform variants.
     * @param address Registry's address to publish the image to.
     *
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
     * @param opts.platformVariants Identifiers for other platform specific containers.
     * Used for multi-platform image.
     * @param opts.forcedCompression Force each layer of the published image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     * @param opts.mediaTypes Use the specified media types for the published image's layers. Defaults to OCI, which
     * is largely compatible with most recent registries, but Docker may be needed for older
     * registries without OCI support.
     */
    publish(address, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "publish",
                    args: Object.assign({ address }, opts),
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves this container's root filesystem. Mounts are not included.
     */
    rootfs() {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "rootfs",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * The error stream of the last executed command.
     *
     * Will execute default command if none is set, or error if there's no default.
     */
    stderr() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "stderr",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The output stream of the last executed command.
     *
     * Will execute default command if none is set, or error if there's no default.
     */
    stdout() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "stdout",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Forces evaluation of the pipeline in the engine.
     *
     * It doesn't run the default command if no exec has been set.
     */
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield computeQuery([
                ...this._queryTree,
                {
                    operation: "sync",
                },
            ], this.client);
            return this;
        });
    }
    /**
     * Retrieves the user to be set for all commands.
     */
    user() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "user",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Configures default arguments for future commands.
     * @param opts.args Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
     */
    withDefaultArgs(opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withDefaultArgs",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a directory written at the given path.
     * @param path Location of the written directory (e.g., "/tmp/directory").
     * @param directory Identifier of the directory to write
     * @param opts.exclude Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
     * @param opts.include Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
     * @param opts.owner A user:group to set for the directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withDirectory(path, directory, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withDirectory",
                    args: Object.assign({ path, directory }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container but with a different command entrypoint.
     * @param args Entrypoint to use for future executions (e.g., ["go", "run"]).
     */
    withEntrypoint(args) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withEntrypoint",
                    args: { args },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus the given environment variable.
     * @param name The name of the environment variable (e.g., "HOST").
     * @param value The value of the environment variable. (e.g., "localhost").
     * @param opts.expand Replace ${VAR} or $VAR in the value according to the current environment
     * variables defined in the container (e.g., "/opt/bin:$PATH").
     */
    withEnvVariable(name, value, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withEnvVariable",
                    args: Object.assign({ name, value }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container after executing the specified command inside it.
     * @param args Command to run instead of the container's default command (e.g., ["run", "main.go"]).
     *
     * If empty, the container's default command is used.
     * @param opts.skipEntrypoint If the container has an entrypoint, ignore it for args rather than using it to wrap them.
     * @param opts.stdin Content to write to the command's standard input before closing (e.g., "Hello world").
     * @param opts.redirectStdout Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
     * @param opts.redirectStderr Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
     * @param opts.experimentalPrivilegedNesting Provides dagger access to the executed command.
     *
     * Do not use this option unless you trust the command being executed.
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
     * @param opts.insecureRootCapabilities Execute the command with all root capabilities. This is similar to running a command
     * with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
     * does not provide any security guarantees when using this option. It should only be used
     * when absolutely necessary and only with trusted commands.
     */
    withExec(args, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withExec",
                    args: Object.assign({ args }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Expose a network port.
     *
     * Exposed ports serve two purposes:
     *   - For health checks and introspection, when running services
     *   - For setting the EXPOSE OCI field when publishing the container
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     * @param port Port number to expose
     * @param opts.protocol Transport layer network protocol
     * @param opts.description Optional port description
     */
    withExposedPort(port, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withExposedPort",
                    args: Object.assign({ port }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Initializes this container from this DirectoryID.
     * @deprecated Replaced by withRootfs.
     */
    withFS(id) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withFS",
                    args: { id },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus the contents of the given file copied to the given path.
     * @param path Location of the copied file (e.g., "/tmp/file.txt").
     * @param source Identifier of the file to copy.
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     * @param opts.owner A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withFile(path, source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withFile",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Indicate that subsequent operations should be featured more prominently in
     * the UI.
     */
    withFocus() {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withFocus",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus the given label.
     * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
     * @param value The value of the label (e.g., "2023-01-01T00:00:00Z").
     */
    withLabel(name, value) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withLabel",
                    args: { name, value },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a cache volume mounted at the given path.
     * @param path Location of the cache directory (e.g., "/cache/node_modules").
     * @param cache Identifier of the cache volume to mount.
     * @param opts.source Identifier of the directory to use as the cache volume's root.
     * @param opts.sharing Sharing mode of the cache volume.
     * @param opts.owner A user:group to set for the mounted cache directory.
     *
     * Note that this changes the ownership of the specified mount along with the
     * initial filesystem provided by source (if any). It does not have any effect
     * if/when the cache has already been created.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedCache(path, cache, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withMountedCache",
                    args: Object.assign({ path, cache }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a directory mounted at the given path.
     * @param path Location of the mounted directory (e.g., "/mnt/directory").
     * @param source Identifier of the mounted directory.
     * @param opts.owner A user:group to set for the mounted directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedDirectory(path, source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withMountedDirectory",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a file mounted at the given path.
     * @param path Location of the mounted file (e.g., "/tmp/file.txt").
     * @param source Identifier of the mounted file.
     * @param opts.owner A user or user:group to set for the mounted file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedFile(path, source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withMountedFile",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a secret mounted into a file at the given path.
     * @param path Location of the secret file (e.g., "/tmp/secret.txt").
     * @param source Identifier of the secret to mount.
     * @param opts.owner A user:group to set for the mounted secret.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedSecret(path, source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withMountedSecret",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a temporary directory mounted at the given path.
     * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
     */
    withMountedTemp(path) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withMountedTemp",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a new file written at the given path.
     * @param path Location of the written file (e.g., "/tmp/file.txt").
     * @param opts.contents Content of the file to write (e.g., "Hello world!").
     * @param opts.permissions Permission given to the written file (e.g., 0600).
     *
     * Default: 0644.
     * @param opts.owner A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withNewFile(path, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withNewFile",
                    args: Object.assign({ path }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container with a registry authentication for a given address.
     * @param address Registry's address to bind the authentication to.
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
     * @param username The username of the registry's account (e.g., "Dagger").
     * @param secret The API key, password or token to authenticate to this registry.
     */
    withRegistryAuth(address, username, secret) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withRegistryAuth",
                    args: { address, username, secret },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Initializes this container from this DirectoryID.
     */
    withRootfs(id) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withRootfs",
                    args: { id },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus an env variable containing the given secret.
     * @param name The name of the secret variable (e.g., "API_SECRET").
     * @param secret The identifier of the secret value.
     */
    withSecretVariable(name, secret) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withSecretVariable",
                    args: { name, secret },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Establish a runtime dependency on a service.
     *
     * The service will be started automatically when needed and detached when it is
     * no longer needed, executing the default command if none is set.
     *
     * The service will be reachable from the container via the provided hostname alias.
     *
     * The service dependency will also convey to any files or directories produced by the container.
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     * @param alias A name that can be used to reach the service from the container
     * @param service Identifier of the service container
     */
    withServiceBinding(alias, service) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withServiceBinding",
                    args: { alias, service },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container plus a socket forwarded to the given Unix socket path.
     * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
     * @param source Identifier of the socket to forward.
     * @param opts.owner A user:group to set for the mounted socket.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withUnixSocket(path, source, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withUnixSocket",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container with a different command user.
     * @param name The user to set (e.g., "root").
     */
    withUser(name) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withUser",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container with a different working directory.
     * @param path The path to set as the working directory (e.g., "/app").
     */
    withWorkdir(path) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withWorkdir",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container minus the given environment variable.
     * @param name The name of the environment variable (e.g., "HOST").
     */
    withoutEnvVariable(name) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutEnvVariable",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Unexpose a previously exposed port.
     *
     * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
     * @param port Port number to unexpose
     * @param opts.protocol Port protocol to unexpose
     */
    withoutExposedPort(port, opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutExposedPort",
                    args: Object.assign({ port }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Indicate that subsequent operations should not be featured more prominently
     * in the UI.
     *
     * This is the initial state of all containers.
     */
    withoutFocus() {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutFocus",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container minus the given environment label.
     * @param name The name of the label to remove (e.g., "org.opencontainers.artifact.created").
     */
    withoutLabel(name) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutLabel",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container after unmounting everything at the given path.
     * @param path Location of the cache directory (e.g., "/cache/node_modules").
     */
    withoutMount(path) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutMount",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container without the registry authentication of a given address.
     * @param address Registry's address to remove the authentication from.
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
     */
    withoutRegistryAuth(address) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutRegistryAuth",
                    args: { address },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this container with a previously added Unix socket removed.
     * @param path Location of the socket to remove (e.g., "/tmp/socket").
     */
    withoutUnixSocket(path) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutUnixSocket",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves the working directory for all commands.
     */
    workdir() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "workdir",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Call the provided function with current Container.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg) {
        return arg(this);
    }
}
/**
 * A directory.
 */
export class Directory extends BaseClient {
    /**
     * Gets the difference between this directory and an another directory.
     * @param other Identifier of the directory to compare.
     */
    diff(other) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "diff",
                    args: { other },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves a directory at the given path.
     * @param path Location of the directory to retrieve (e.g., "/src").
     */
    directory(path) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "directory",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Builds a new Docker container from this directory.
     * @param opts.dockerfile Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
     *
     * Defaults: './Dockerfile'.
     * @param opts.platform The platform to build.
     * @param opts.buildArgs Build arguments to use in the build.
     * @param opts.target Target build stage to build.
     * @param opts.secrets Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name].
     */
    dockerBuild(opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "dockerBuild",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Returns a list of files and directories at the given path.
     * @param opts.path Location of the directory to look at (e.g., "/src").
     */
    entries(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "entries",
                    args: Object.assign({}, opts),
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Writes the contents of the directory to a path on the host.
     * @param path Location of the copied directory (e.g., "logs/").
     */
    export(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "export",
                    args: { path },
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves a file at the given path.
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    file(path) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "file",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * The content-addressed identifier of the directory.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Creates a named sub-pipeline
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "pipeline",
                    args: Object.assign({ name }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Force evaluation in the engine.
     */
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield computeQuery([
                ...this._queryTree,
                {
                    operation: "sync",
                },
            ], this.client);
            return this;
        });
    }
    /**
     * Retrieves this directory plus a directory written at the given path.
     * @param path Location of the written directory (e.g., "/src/").
     * @param directory Identifier of the directory to copy.
     * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    withDirectory(path, directory, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withDirectory",
                    args: Object.assign({ path, directory }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory plus the contents of the given file copied to the given path.
     * @param path Location of the copied file (e.g., "/file.txt").
     * @param source Identifier of the file to copy.
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    withFile(path, source, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withFile",
                    args: Object.assign({ path, source }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory plus a new directory created at the given path.
     * @param path Location of the directory created (e.g., "/logs").
     * @param opts.permissions Permission granted to the created directory (e.g., 0777).
     *
     * Default: 0755.
     */
    withNewDirectory(path, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withNewDirectory",
                    args: Object.assign({ path }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory plus a new file written at the given path.
     * @param path Location of the written file (e.g., "/file.txt").
     * @param contents Content of the written file (e.g., "Hello world!").
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    withNewFile(path, contents, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withNewFile",
                    args: Object.assign({ path, contents }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory with all file/dir timestamps set to the given time.
     * @param timestamp Timestamp to set dir/files in.
     *
     * Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    withTimestamps(timestamp) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withTimestamps",
                    args: { timestamp },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory with the directory at the given path removed.
     * @param path Location of the directory to remove (e.g., ".github/").
     */
    withoutDirectory(path) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutDirectory",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves this directory with the file at the given path removed.
     * @param path Location of the file to remove (e.g., "/file.txt").
     */
    withoutFile(path) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withoutFile",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Call the provided function with current Directory.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg) {
        return arg(this);
    }
}
/**
 * A simple key value object that represents an environment variable.
 */
export class EnvVariable extends BaseClient {
    /**
     * The environment variable name.
     */
    name() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "name",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The environment variable value.
     */
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "value",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * A file.
 */
export class File extends BaseClient {
    /**
     * Retrieves the contents of the file.
     */
    contents() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "contents",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Writes the file to a file path on the host.
     * @param path Location of the written directory (e.g., "output.txt").
     * @param opts.allowParentDirPath If allowParentDirPath is true, the path argument can be a directory path, in which case
     * the file will be created in that directory.
     */
    export(path, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "export",
                    args: Object.assign({ path }, opts),
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves the content-addressed identifier of the file.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Retrieves a secret referencing the contents of this file.
     * @deprecated insecure, leaves secret in cache. Superseded by setSecret
     */
    secret() {
        return new Secret({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "secret",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Gets the size of the file, in bytes.
     */
    size() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "size",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Force evaluation in the engine.
     */
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield computeQuery([
                ...this._queryTree,
                {
                    operation: "sync",
                },
            ], this.client);
            return this;
        });
    }
    /**
     * Retrieves this file with its created/modified timestamps set to the given time.
     * @param timestamp Timestamp to set dir/files in.
     *
     * Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    withTimestamps(timestamp) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "withTimestamps",
                    args: { timestamp },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Call the provided function with current File.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg) {
        return arg(this);
    }
}
/**
 * A git ref (tag, branch or commit).
 */
export class GitRef extends BaseClient {
    /**
     * The filesystem tree at this ref.
     */
    tree(opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "tree",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
}
/**
 * A git repository.
 */
export class GitRepository extends BaseClient {
    /**
     * Returns details on one branch.
     * @param name Branch's name (e.g., "main").
     */
    branch(name) {
        return new GitRef({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "branch",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Returns details on one commit.
     * @param id Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
     */
    commit(id) {
        return new GitRef({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "commit",
                    args: { id },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Returns details on one tag.
     * @param name Tag's name (e.g., "v0.3.9").
     */
    tag(name) {
        return new GitRef({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "tag",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
}
/**
 * Information about the host execution environment.
 */
export class Host extends BaseClient {
    /**
     * Accesses a directory on the host.
     * @param path Location of the directory to access (e.g., ".").
     * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    directory(path, opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "directory",
                    args: Object.assign({ path }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Accesses an environment variable on the host.
     * @param name Name of the environment variable (e.g., "PATH").
     */
    envVariable(name) {
        return new HostVariable({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "envVariable",
                    args: { name },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Accesses a file on the host.
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    file(path) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "file",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Accesses a Unix socket on the host.
     * @param path Location of the Unix socket (e.g., "/var/run/docker.sock").
     */
    unixSocket(path) {
        return new Socket({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "unixSocket",
                    args: { path },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Retrieves the current working directory on the host.
     * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     * @deprecated Use directory with path set to '.' instead.
     */
    workdir(opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "workdir",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
}
/**
 * An environment variable on the host environment.
 */
export class HostVariable extends BaseClient {
    /**
     * A secret referencing the value of this variable.
     * @deprecated been superseded by setSecret
     */
    secret() {
        return new Secret({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "secret",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * The value of this variable.
     */
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "value",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * A simple key value object that represents a label.
 */
export class Label extends BaseClient {
    /**
     * The label name.
     */
    name() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "name",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The label value.
     */
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "value",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * A port exposed by a container.
 */
export class Port extends BaseClient {
    /**
     * The port description.
     */
    description() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "description",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The port number.
     */
    port() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "port",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The transport layer network protocol.
     */
    protocol() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "protocol",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * A collection of Dagger resources that can be queried and invoked.
 */
export class Project extends BaseClient {
    /**
     * Commands provided by this project
     */
    commands() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "commands",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * A unique identifier for this project.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Initialize this project from the given directory and config path
     */
    load(source, configPath) {
        return new Project({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "load",
                    args: { source, configPath },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Name of the project
     */
    name() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "name",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Call the provided function with current Project.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg) {
        return arg(this);
    }
}
/**
 * A command defined in a project that can be invoked from the CLI.
 */
export class ProjectCommand extends BaseClient {
    /**
     * Documentation for what this command does.
     */
    description() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "description",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Flags accepted by this command.
     */
    flags() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "flags",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * A unique identifier for this command.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The name of the command.
     */
    name() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "name",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The name of the type returned by this command.
     */
    resultType() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "resultType",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Subcommands, if any, that this command provides.
     */
    subcommands() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "subcommands",
                },
            ], this.client);
            return response;
        });
    }
}
/**
 * A flag accepted by a project command.
 */
export class ProjectCommandFlag extends BaseClient {
    /**
     * Documentation for what this flag sets.
     */
    description() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "description",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The name of the flag.
     */
    name() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "name",
                },
            ], this.client);
            return response;
        });
    }
}
export default class Client extends BaseClient {
    /**
     * Constructs a cache volume for a given cache key.
     * @param key A string identifier to target this cache volume (e.g., "modules-cache").
     */
    cacheVolume(key) {
        return new CacheVolume({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "cacheVolume",
                    args: { key },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Loads a container from ID.
     *
     * Null ID returns an empty container (scratch).
     * Optional platform argument initializes new containers to execute and publish as that platform.
     * Platform defaults to that of the builder's host.
     */
    container(opts) {
        return new Container({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "container",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * The default platform of the builder.
     */
    defaultPlatform() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "defaultPlatform",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * Load a directory by ID. No argument produces an empty directory.
     */
    directory(opts) {
        return new Directory({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "directory",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Loads a file by ID.
     */
    file(id) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "file",
                    args: { id },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Queries a git repository.
     * @param url Url of the git repository.
     * Can be formatted as https://{host}/{owner}/{repo}, git@{host}/{owner}/{repo}
     * Suffix ".git" is optional.
     * @param opts.keepGitDir Set to true to keep .git directory.
     * @param opts.experimentalServiceHost A service which must be started before the repo is fetched.
     */
    git(url, opts) {
        return new GitRepository({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "git",
                    args: Object.assign({ url }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Queries the host environment.
     */
    host() {
        return new Host({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "host",
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Returns a file containing an http remote url content.
     * @param url HTTP url to get the content from (e.g., "https://docs.dagger.io").
     * @param opts.experimentalServiceHost A service which must be started before the URL is fetched.
     */
    http(url, opts) {
        return new File({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "http",
                    args: Object.assign({ url }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Creates a named sub-pipeline.
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name, opts) {
        return new Client({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "pipeline",
                    args: Object.assign({ name }, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Load a project from ID.
     */
    project(opts) {
        return new Project({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "project",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Load a project command from ID.
     */
    projectCommand(opts) {
        return new ProjectCommand({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "projectCommand",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Loads a secret from its ID.
     */
    secret(id) {
        return new Secret({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "secret",
                    args: { id },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Sets a secret given a user defined name to its plaintext and returns the secret.
     * The plaintext value is limited to a size of 128000 bytes.
     * @param name The user defined name for this secret
     * @param plaintext The plaintext of the secret
     */
    setSecret(name, plaintext) {
        return new Secret({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "setSecret",
                    args: { name, plaintext },
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Loads a socket by its ID.
     */
    socket(opts) {
        return new Socket({
            queryTree: [
                ...this._queryTree,
                {
                    operation: "socket",
                    args: Object.assign({}, opts),
                },
            ],
            host: this.clientHost,
            sessionToken: this.sessionToken,
        });
    }
    /**
     * Call the provided function with current Client.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg) {
        return arg(this);
    }
}
/**
 * A reference to a secret value, which can be handled more safely than the value itself.
 */
export class Secret extends BaseClient {
    /**
     * The identifier for this secret.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
    /**
     * The value of this secret.
     */
    plaintext() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "plaintext",
                },
            ], this.client);
            return response;
        });
    }
}
export class Socket extends BaseClient {
    /**
     * The content-addressed identifier of the socket.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield computeQuery([
                ...this._queryTree,
                {
                    operation: "id",
                },
            ], this.client);
            return response;
        });
    }
}
