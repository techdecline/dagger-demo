var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientError, gql } from "graphql-request";
import { GraphQLRequestError, TooManyNestedObjectsError, UnknownDaggerError, NotAwaitedRequestError, ExecError, } from "../common/errors/index.js";
/**
 * Format argument into GraphQL query format.
 */
function buildArgs(args) {
    // Remove unwanted quotes
    const formatValue = (value) => JSON.stringify(value).replace(/\{"[a-zA-Z]+":|,"[a-zA-Z]+":/gi, (str) => str.replace(/"/g, ""));
    if (args === undefined || args === null) {
        return "";
    }
    const formattedArgs = Object.entries(args).reduce((acc, [key, value]) => {
        if (value !== undefined && value !== null) {
            acc.push(`${key}: ${formatValue(value)}`);
        }
        return acc;
    }, []);
    if (formattedArgs.length === 0) {
        return "";
    }
    return `(${formattedArgs})`;
}
/**
 * Find QueryTree, convert them into GraphQl query
 * then compute and return the result to the appropriate field
 */
function computeNestedQuery(query, client) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check if there is a nested queryTree to be executed
        const isQueryTree = (value) => value["_queryTree"] !== undefined;
        // Check if there is a nested array of queryTree to be executed
        const isArrayQueryTree = (value) => value.every((v) => v instanceof Object && isQueryTree(v));
        // Prepare query tree for final query by computing nested queries
        // and building it with their results.
        const computeQueryTree = (value) => __awaiter(this, void 0, void 0, function* () {
            // Resolve sub queries if operation's args is a subquery
            for (const op of value["_queryTree"]) {
                yield computeNestedQuery([op], client);
            }
            // push an id that will be used by the container
            return buildQuery([
                ...value["_queryTree"],
                {
                    operation: "id",
                },
            ]);
        });
        // Remove all undefined args and assert args type
        const queryToExec = query.filter((q) => !!q.args);
        for (const q of queryToExec) {
            yield Promise.all(
            // Compute nested query for single object
            Object.entries(q.args).map(([key, value]) => __awaiter(this, void 0, void 0, function* () {
                if (value instanceof Object && isQueryTree(value)) {
                    // push an id that will be used by the container
                    const getQueryTree = yield computeQueryTree(value);
                    q.args[key] = yield compute(getQueryTree, client);
                }
                // Compute nested query for array of object
                if (Array.isArray(value) && isArrayQueryTree(value)) {
                    const tmp = q.args[key];
                    for (let i = 0; i < value.length; i++) {
                        // push an id that will be used by the container
                        const getQueryTree = yield computeQueryTree(value[i]);
                        tmp[i] = yield compute(getQueryTree, client);
                    }
                    q.args[key] = tmp;
                }
            })));
        }
    });
}
/**
 * Convert the queryTree into a GraphQL query
 * @param q
 * @returns
 */
export function buildQuery(q) {
    const query = q.reduce((acc, { operation, args }, i) => {
        const qLen = q.length;
        acc += ` ${operation} ${args ? `${buildArgs(args)}` : ""} ${qLen - 1 !== i ? "{" : "}".repeat(qLen - 1)}`;
        return acc;
    }, "");
    return `{${query} }`;
}
/**
 * Convert querytree into a Graphql query then compute it
 * @param q | QueryTree[]
 * @param client | GraphQLClient
 * @returns
 */
export function computeQuery(q, client) {
    return __awaiter(this, void 0, void 0, function* () {
        yield computeNestedQuery(q, client);
        const query = buildQuery(q);
        return yield compute(query, client);
    });
}
/**
 * Return a Graphql query result flattened
 * @param response any
 * @returns
 */
export function queryFlatten(response) {
    // Recursion break condition
    // If our response is not an object or an array we assume we reached the value
    if (!(response instanceof Object) || Array.isArray(response)) {
        return response;
    }
    const keys = Object.keys(response);
    if (keys.length != 1) {
        // Dagger is currently expecting to only return one value
        // If the response is nested in a way were more than one object is nested inside throw an error
        throw new TooManyNestedObjectsError("Too many nested objects inside graphql response", { response: response });
    }
    const nestedKey = keys[0];
    return queryFlatten(response[nestedKey]);
}
/**
 * Send a GraphQL document to the server
 * return a flatten result
 * @hidden
 */
export function compute(query, client) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return __awaiter(this, void 0, void 0, function* () {
        let computeQuery;
        try {
            computeQuery = yield client.request(gql `
        ${query}
      `);
        }
        catch (e) {
            if (e instanceof ClientError) {
                const msg = (_c = (_b = (_a = e.response.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : `API Error`;
                const ext = (_e = (_d = e.response.errors) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.extensions;
                if ((ext === null || ext === void 0 ? void 0 : ext._type) === "EXEC_ERROR") {
                    throw new ExecError(msg, {
                        cmd: (_f = ext.cmd) !== null && _f !== void 0 ? _f : [],
                        exitCode: (_g = ext.exitCode) !== null && _g !== void 0 ? _g : -1,
                        stdout: (_h = ext.stdout) !== null && _h !== void 0 ? _h : "",
                        stderr: (_j = ext.stderr) !== null && _j !== void 0 ? _j : "",
                    });
                }
                throw new GraphQLRequestError(msg, {
                    request: e.request,
                    response: e.response,
                    cause: e,
                });
            }
            // Looking for connection error in case the function has not been awaited.
            if (e.errno === "ECONNREFUSED") {
                throw new NotAwaitedRequestError("Encountered an error while requesting data via graphql through a synchronous call. Make sure the function called is awaited.", { cause: e });
            }
            // Just throw the unknown error
            throw new UnknownDaggerError("Encountered an unknown error while requesting data via graphql", { cause: e });
        }
        return queryFlatten(computeQuery);
    });
}
