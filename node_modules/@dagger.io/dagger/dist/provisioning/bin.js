var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import AdmZip from "adm-zip";
import * as crypto from "crypto";
import envPaths from "env-paths";
import { execaCommand } from "execa";
import * as fs from "fs";
import fetch from "node-fetch";
import * as os from "os";
import * as path from "path";
import * as process from "process";
import readline from "readline";
import * as tar from "tar";
import { fileURLToPath } from "url";
import Client from "../api/client.gen.js";
import { EngineSessionConnectionTimeoutError, EngineSessionConnectParamsParseError, EngineSessionError, InitEngineSessionBinaryError, } from "../common/errors/index.js";
const CLI_HOST = "dl.dagger.io";
let OVERRIDE_CLI_URL;
let OVERRIDE_CHECKSUMS_URL;
/**
 * Bin runs an engine session from a specified binary
 */
export class Bin {
    constructor(binPath, cliVersion) {
        var _a;
        this.cacheDir = path.join(`${((_a = process.env.XDG_CACHE_HOME) === null || _a === void 0 ? void 0 : _a.trim()) || envPaths("", { suffix: "" }).cache}`, "dagger");
        this.DAGGER_CLI_BIN_PREFIX = "dagger";
        this.binPath = binPath;
        this.cliVersion = cliVersion;
    }
    Addr() {
        return "http://dagger";
    }
    Connect(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.binPath) {
                this.binPath = yield this.downloadCLI();
            }
            return this.runEngineSession(this.binPath, opts);
        });
    }
    downloadCLI() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cliVersion) {
                throw new Error("cliVersion is not set");
            }
            const binPath = this.buildBinPath();
            // Create a temporary bin file path
            this.createCacheDir();
            const tmpBinDownloadDir = fs.mkdtempSync(path.join(this.cacheDir, `temp-${this.getRandomId()}`));
            const tmpBinPath = this.buildOsExePath(tmpBinDownloadDir, this.DAGGER_CLI_BIN_PREFIX);
            try {
                // download an archive and use appropriate extraction depending on platforms (zip on windows, tar.gz on other platforms)
                const actualChecksum = yield this.extractArchive(tmpBinDownloadDir, this.normalizedOS());
                const expectedChecksum = yield this.expectedChecksum();
                if (actualChecksum !== expectedChecksum) {
                    throw new Error(`checksum mismatch: expected ${expectedChecksum}, got ${actualChecksum}`);
                }
                fs.chmodSync(tmpBinPath, 0o700);
                fs.renameSync(tmpBinPath, binPath);
                fs.rmSync(tmpBinDownloadDir, { recursive: true });
            }
            catch (e) {
                fs.rmSync(tmpBinDownloadDir, { recursive: true });
                throw new InitEngineSessionBinaryError(`failed to download dagger cli binary: ${e}`, { cause: e });
            }
            // Remove all temporary binary files
            // Ignore current dagger cli or other files that have not be
            // created by this SDK.
            try {
                const files = fs.readdirSync(this.cacheDir);
                files.forEach((file) => {
                    const filePath = path.join(this.cacheDir, file);
                    if (filePath === binPath ||
                        !file.startsWith(this.DAGGER_CLI_BIN_PREFIX)) {
                        return;
                    }
                    fs.unlinkSync(filePath);
                });
            }
            catch (e) {
                // Log the error but do not interrupt program.
                console.error("could not clean up temporary binary files");
            }
            return binPath;
        });
    }
    /**
     * Traverse up the directory tree to find the package.json file and return the
     * SDK version.
     * @returns the SDK version or "n/a" if the version cannot be found.
     */
    getSDKVersion() {
        const currentFileUrl = import.meta.url;
        const currentFilePath = fileURLToPath(currentFileUrl);
        let currentPath = path.dirname(currentFilePath);
        while (currentPath !== path.parse(currentPath).root) {
            const packageJsonPath = path.join(currentPath, "package.json");
            if (fs.existsSync(packageJsonPath)) {
                try {
                    const packageJsonContent = fs.readFileSync(packageJsonPath, "utf8");
                    const packageJson = JSON.parse(packageJsonContent);
                    return packageJson.version;
                }
                catch (error) {
                    return "n/a";
                }
            }
            else {
                currentPath = path.join(currentPath, "..");
            }
        }
    }
    /**
     * runEngineSession execute the engine binary and set up a GraphQL client that
     * target this engine.
     */
    runEngineSession(binPath, opts) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const args = [binPath, "session"];
            const sdkVersion = this.getSDKVersion();
            const flagsAndValues = [
                { flag: "--workdir", value: opts.Workdir },
                { flag: "--project", value: opts.Project },
                { flag: "--label", value: "dagger.io/sdk.name:nodejs" },
                { flag: "--label", value: `dagger.io/sdk.version:${sdkVersion}` },
            ];
            flagsAndValues.forEach((pair) => {
                if (pair.value) {
                    args.push(pair.flag, pair.value);
                }
            });
            this.subProcess = execaCommand(args.join(" "), {
                stdio: "pipe",
                reject: true,
                // Kill the process if parent exit.
                cleanup: true,
            });
            // Log the output if the user wants to.
            if (opts.LogOutput) {
                (_a = this.subProcess.stderr) === null || _a === void 0 ? void 0 : _a.pipe(opts.LogOutput);
            }
            const stdoutReader = readline.createInterface({
                input: (_b = this.subProcess) === null || _b === void 0 ? void 0 : _b.stdout,
            });
            const timeOutDuration = 300000;
            const connectParams = (yield Promise.race([
                this.readConnectParams(stdoutReader),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new EngineSessionConnectionTimeoutError("timeout reading connect params from engine session", { timeOutDuration }));
                    }, timeOutDuration).unref(); // long timeout to account for extensions, though that should be optimized in future
                }),
            ]));
            return new Client({
                host: `127.0.0.1:${connectParams.port}`,
                sessionToken: connectParams.session_token,
            });
        });
    }
    readConnectParams(stdoutReader) {
        var _a, stdoutReader_1, stdoutReader_1_1;
        var _b, e_1, _c, _d;
        var _e;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (_a = true, stdoutReader_1 = __asyncValues(stdoutReader); stdoutReader_1_1 = yield stdoutReader_1.next(), _b = stdoutReader_1_1.done, !_b; _a = true) {
                    _d = stdoutReader_1_1.value;
                    _a = false;
                    const line = _d;
                    // parse the the line as json-encoded connect params
                    const connectParams = JSON.parse(line);
                    if (connectParams.port && connectParams.session_token) {
                        return connectParams;
                    }
                    throw new EngineSessionConnectParamsParseError(`invalid connect params: ${line}`, { parsedLine: line });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_a && !_b && (_c = stdoutReader_1.return)) yield _c.call(stdoutReader_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Need to find a better way to handle this part
            // At this stage something wrong happened, `for await` didn't return anything
            // await the subprocess to catch the error
            try {
                yield this.subProcess;
            }
            catch (_f) {
                (_e = this.subProcess) === null || _e === void 0 ? void 0 : _e.catch((e) => {
                    throw new EngineSessionError(e.stderr);
                });
            }
        });
    }
    Close() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.subProcess) === null || _a === void 0 ? void 0 : _a.pid) {
                this.subProcess.kill("SIGTERM", {
                    // Set a long timeout to give time for any cache exports to pack layers up
                    // which currently has to happen synchronously with the session.
                    forceKillAfterTimeout: 300000, // 5 mins
                });
            }
        });
    }
    /**
     * createCacheDir will create a cache directory on user
     * host to store dagger binary.
     *
     * If set, it will use envPaths to determine system's cache directory,
     * if not, it will use `$HOME/.cache` as base path.
     * Nothing happens if the directory already exists.
     */
    createCacheDir() {
        fs.mkdirSync(this.cacheDir, { mode: 0o700, recursive: true });
    }
    /**
     * buildBinPath create a path to output dagger cli binary.
     *
     * It will store it in the cache directory with a name composed
     * of the base engine session as constant and the engine identifier.
     */
    buildBinPath() {
        return this.buildOsExePath(this.cacheDir, `${this.DAGGER_CLI_BIN_PREFIX}-${this.cliVersion}`);
    }
    /**
     * buildExePath create a path to output dagger cli binary.
     */
    buildOsExePath(destinationDir, filename) {
        const binPath = path.join(destinationDir, filename);
        switch (this.normalizedOS()) {
            case "windows":
                return `${binPath}.exe`;
            default:
                return binPath;
        }
    }
    /**
     * normalizedArch returns the architecture name used by the rest of our SDKs.
     */
    normalizedArch() {
        switch (os.arch()) {
            case "x64":
                return "amd64";
            default:
                return os.arch();
        }
    }
    /**
     * normalizedOS returns the os name used by the rest of our SDKs.
     */
    normalizedOS() {
        switch (os.platform()) {
            case "win32":
                return "windows";
            default:
                return os.platform();
        }
    }
    cliArchiveName() {
        if (OVERRIDE_CLI_URL) {
            return path.basename(new URL(OVERRIDE_CLI_URL).pathname);
        }
        let ext = "tar.gz";
        if (this.normalizedOS() === "windows") {
            ext = "zip";
        }
        return `dagger_v${this.cliVersion}_${this.normalizedOS()}_${this.normalizedArch()}.${ext}`;
    }
    cliArchiveURL() {
        if (OVERRIDE_CLI_URL) {
            return OVERRIDE_CLI_URL;
        }
        return `https://${CLI_HOST}/dagger/releases/${this.cliVersion}/${this.cliArchiveName()}`;
    }
    cliChecksumURL() {
        if (OVERRIDE_CHECKSUMS_URL) {
            return OVERRIDE_CHECKSUMS_URL;
        }
        return `https://${CLI_HOST}/dagger/releases/${this.cliVersion}/checksums.txt`;
    }
    checksumMap() {
        return __awaiter(this, void 0, void 0, function* () {
            // download checksums.txt
            const checksums = yield fetch(this.cliChecksumURL());
            if (!checksums.ok) {
                throw new Error(`failed to download checksums.txt from ${this.cliChecksumURL()}`);
            }
            const checksumsText = yield checksums.text();
            // iterate over lines filling in map of filename -> checksum
            const checksumMap = new Map();
            for (const line of checksumsText.split("\n")) {
                const [checksum, filename] = line.split(/\s+/);
                checksumMap.set(filename, checksum);
            }
            return checksumMap;
        });
    }
    expectedChecksum() {
        return __awaiter(this, void 0, void 0, function* () {
            const checksumMap = yield this.checksumMap();
            const expectedChecksum = checksumMap.get(this.cliArchiveName());
            if (!expectedChecksum) {
                throw new Error(`failed to find checksum for ${this.cliArchiveName()} in checksums.txt`);
            }
            return expectedChecksum;
        });
    }
    extractArchive(destDir, os) {
        return __awaiter(this, void 0, void 0, function* () {
            // extract the dagger binary in the cli archive and return the archive of the .zip for windows and .tar.gz for other plateforms
            const archiveResp = yield fetch(this.cliArchiveURL());
            if (!archiveResp.ok) {
                throw new Error(`failed to download dagger cli archive from ${this.cliArchiveURL()}`);
            }
            if (!archiveResp.body) {
                throw new Error("archive response body is null");
            }
            // create a temporary file to store the archive
            const archivePath = path.join(destDir, os === "windows" ? "dagger.zip" : "dagger.tar.gz");
            const archiveFile = fs.createWriteStream(archivePath);
            yield new Promise((resolve, reject) => {
                var _a, _b;
                (_a = archiveResp.body) === null || _a === void 0 ? void 0 : _a.pipe(archiveFile);
                (_b = archiveResp.body) === null || _b === void 0 ? void 0 : _b.on("error", reject);
                archiveFile.on("finish", resolve);
            });
            const actualChecksum = crypto
                .createHash("sha256")
                .update(fs.readFileSync(archivePath))
                .digest("hex");
            if (os === "windows") {
                const zip = new AdmZip(archivePath);
                // extract just dagger.exe to the destdir
                zip.extractEntryTo("dagger.exe", destDir, false, true);
            }
            else {
                tar.extract({
                    cwd: destDir,
                    file: archivePath,
                    sync: true,
                });
            }
            return actualChecksum;
        });
    }
    /**
     * Generate a unix timestamp in nanosecond
     */
    getRandomId() {
        return process.hrtime.bigint().toString();
    }
}
// Only meant for tests
export function _overrideCLIURL(url) {
    OVERRIDE_CLI_URL = url;
}
// Only meant for tests
export function _overrideCLIChecksumsURL(url) {
    OVERRIDE_CHECKSUMS_URL = url;
}
