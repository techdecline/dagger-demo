"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAxiosFetch = void 0;
const typeUtils_1 = require("./typeUtils");
/**
 * A Fetch WebAPI implementation based on the Axios client
 */
const axiosFetch = (axios, 
// Convert the `fetch` style arguments into a Axios style config
transformer = (config) => config) => async (input, init) => {
    const rawHeaders = (0, typeUtils_1.createAxiosHeaders)(init === null || init === void 0 ? void 0 : init.headers);
    const lowerCasedHeaders = {};
    Object.entries(rawHeaders).forEach(([name, value]) => {
        lowerCasedHeaders[name.toLowerCase()] = value;
    });
    if (!('content-type' in lowerCasedHeaders)) {
        lowerCasedHeaders['content-type'] = 'text/plain;charset=UTF-8';
    }
    const rawConfig = {
        url: (0, typeUtils_1.getUrl)(input),
        method: (init === null || init === void 0 ? void 0 : init.method) || 'GET',
        data: init === null || init === void 0 ? void 0 : init.body,
        headers: lowerCasedHeaders,
        // Force the response to an arraybuffer type. Without this, the Response
        // object will try to guess the content type and add headers that weren't in
        // the response.
        // NOTE: Don't use 'stream' because it's not supported in the browser
        responseType: 'arraybuffer'
    };
    const config = transformer(rawConfig, input, init);
    let result;
    try {
        result = await axios.request(config);
    }
    catch (err) {
        if (err.response) {
            result = err.response;
        }
        else {
            throw err;
        }
    }
    return new Response(result.data, {
        status: result.status,
        statusText: result.statusText,
        headers: (0, typeUtils_1.createFetchHeaders)(result.headers)
    });
};
const buildAxiosFetch = (axios, transformer) => axiosFetch(axios, transformer);
exports.buildAxiosFetch = buildAxiosFetch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQ0FJcUI7QUFNckI7O0dBRUc7QUFDSCxNQUFNLFVBQVUsR0FBRyxDQUNqQixLQUFvQjtBQUNwQixnRUFBZ0U7QUFDaEUsY0FBc0MsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFDeEQsRUFBRSxDQUFDLEtBQUssRUFDTixLQUFrQixFQUNsQixJQUFXLEVBQ1gsRUFBRTtJQUNGLE1BQU0sVUFBVSxHQUFHLElBQUEsOEJBQWtCLEVBQUMsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3JELE1BQU0saUJBQWlCLEdBQTJCLEVBQUUsQ0FBQztJQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDbkQsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ2hELENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLENBQUMsY0FBYyxJQUFJLGlCQUFpQixDQUFDLEVBQUU7UUFDMUMsaUJBQWlCLENBQUMsY0FBYyxDQUFDLEdBQUcsMEJBQTBCLENBQUM7S0FDaEU7SUFFRCxNQUFNLFNBQVMsR0FBdUI7UUFDcEMsR0FBRyxFQUFFLElBQUEsa0JBQU0sRUFBQyxLQUFLLENBQUM7UUFDbEIsTUFBTSxFQUFFLENBQUMsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE1BQXVDLEtBQUksS0FBSztRQUMvRCxJQUFJLEVBQUUsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLElBQUk7UUFDaEIsT0FBTyxFQUFFLGlCQUFpQjtRQUMxQix3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLGdCQUFnQjtRQUNoQixxRUFBcUU7UUFDckUsWUFBWSxFQUFFLGFBQWE7S0FDNUIsQ0FBQztJQUVGLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRW5ELElBQUksTUFBTSxDQUFDO0lBQ1gsSUFBSTtRQUNGLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdEM7SUFBQyxPQUFPLEdBQVEsRUFBRTtRQUNqQixJQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUU7WUFDaEIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUM7U0FDdkI7YUFBTTtZQUNMLE1BQU0sR0FBRyxDQUFDO1NBQ1g7S0FDRjtJQUVELE9BQU8sSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtRQUMvQixNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU07UUFDckIsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1FBQzdCLE9BQU8sRUFBRSxJQUFBLDhCQUFrQixFQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7S0FDNUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDO0FBRUcsTUFBTSxlQUFlLEdBQUcsQ0FDN0IsS0FBb0IsRUFDcEIsV0FBb0MsRUFDcEMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFIdkIsUUFBQSxlQUFlLG1CQUdRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY3JlYXRlQXhpb3NIZWFkZXJzLFxuICBjcmVhdGVGZXRjaEhlYWRlcnMsXG4gIGdldFVybFxufSBmcm9tICcuL3R5cGVVdGlscyc7XG5pbXBvcnQgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tICcuL2F4aW9zLXR5cGVzJztcblxuZXhwb3J0IHR5cGUgQXhpb3NUcmFuc2Zvcm1lcjxJbml0IGV4dGVuZHMgUmVxdWVzdEluaXQgPSBSZXF1ZXN0SW5pdD4gPVxuICAoY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWcsIGlucHV0OiBSZXF1ZXN0SW5mbywgaW5pdD86IEluaXQpID0+IEF4aW9zUmVxdWVzdENvbmZpZztcblxuLyoqXG4gKiBBIEZldGNoIFdlYkFQSSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgQXhpb3MgY2xpZW50XG4gKi9cbmNvbnN0IGF4aW9zRmV0Y2ggPSA8SW5pdCBleHRlbmRzIFJlcXVlc3RJbml0ID0gUmVxdWVzdEluaXQ+KFxuICBheGlvczogQXhpb3NJbnN0YW5jZSxcbiAgLy8gQ29udmVydCB0aGUgYGZldGNoYCBzdHlsZSBhcmd1bWVudHMgaW50byBhIEF4aW9zIHN0eWxlIGNvbmZpZ1xuICB0cmFuc2Zvcm1lcjogQXhpb3NUcmFuc2Zvcm1lcjxJbml0PiA9IChjb25maWcpID0+IGNvbmZpZ1xuKSA9PiBhc3luYyAoXG4gICAgaW5wdXQ6IFJlcXVlc3RJbmZvLFxuICAgIGluaXQ/OiBJbml0XG4gICkgPT4ge1xuICAgIGNvbnN0IHJhd0hlYWRlcnMgPSBjcmVhdGVBeGlvc0hlYWRlcnMoaW5pdD8uaGVhZGVycyk7XG4gICAgY29uc3QgbG93ZXJDYXNlZEhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhyYXdIZWFkZXJzKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICBsb3dlckNhc2VkSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBpZiAoISgnY29udGVudC10eXBlJyBpbiBsb3dlckNhc2VkSGVhZGVycykpIHtcbiAgICAgIGxvd2VyQ2FzZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd0NvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgdXJsOiBnZXRVcmwoaW5wdXQpLFxuICAgICAgbWV0aG9kOiAoaW5pdD8ubWV0aG9kIGFzIEF4aW9zUmVxdWVzdENvbmZpZ1snbWV0aG9kJ10pIHx8ICdHRVQnLFxuICAgICAgZGF0YTogaW5pdD8uYm9keSxcbiAgICAgIGhlYWRlcnM6IGxvd2VyQ2FzZWRIZWFkZXJzLFxuICAgICAgLy8gRm9yY2UgdGhlIHJlc3BvbnNlIHRvIGFuIGFycmF5YnVmZmVyIHR5cGUuIFdpdGhvdXQgdGhpcywgdGhlIFJlc3BvbnNlXG4gICAgICAvLyBvYmplY3Qgd2lsbCB0cnkgdG8gZ3Vlc3MgdGhlIGNvbnRlbnQgdHlwZSBhbmQgYWRkIGhlYWRlcnMgdGhhdCB3ZXJlbid0IGluXG4gICAgICAvLyB0aGUgcmVzcG9uc2UuXG4gICAgICAvLyBOT1RFOiBEb24ndCB1c2UgJ3N0cmVhbScgYmVjYXVzZSBpdCdzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgIH07XG5cbiAgICBjb25zdCBjb25maWcgPSB0cmFuc2Zvcm1lcihyYXdDb25maWcsIGlucHV0LCBpbml0KTtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGF4aW9zLnJlcXVlc3QoY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgaWYgKGVyci5yZXNwb25zZSkge1xuICAgICAgICByZXN1bHQgPSBlcnIucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXN1bHQuZGF0YSwge1xuICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogcmVzdWx0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBjcmVhdGVGZXRjaEhlYWRlcnMocmVzdWx0LmhlYWRlcnMpXG4gICAgfSk7XG4gIH07XG5cbmV4cG9ydCBjb25zdCBidWlsZEF4aW9zRmV0Y2ggPSA8SW5pdCBleHRlbmRzIFJlcXVlc3RJbml0ID0gUmVxdWVzdEluaXQ+IChcbiAgYXhpb3M6IEF4aW9zSW5zdGFuY2UsXG4gIHRyYW5zZm9ybWVyPzogQXhpb3NUcmFuc2Zvcm1lcjxJbml0PlxuKSA9PiBheGlvc0ZldGNoKGF4aW9zLCB0cmFuc2Zvcm1lcik7XG4iXX0=